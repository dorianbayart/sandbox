<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Pixel Perfect Converter</title>

</head>

<body>
  <header>
    <h1 class="cursive">Pixel Perfect Converter</h1>
    <subtitle>Online Pixel Art to SVG Converter: Transform Images into Scalable Vector Graphics</subtitle>
  </header>

  <main>
    <section class="centered">

      <div class="input-section">
        <h2>Input Image</h2>
        <div class="flex">
          <input type="file" id="imageUpload" accept="image/*">
          <span>OR</span>
          <textarea id="base64Input" placeholder="Paste base64 image data here..."></textarea>
        </div>
        <div class="image-preview" id="inputImagePreview">Preview</div>
        <span id="inputImageSize" class="image-size"></span>
      </div>

    </section>

    <hr>
    
    <section class="centered">

      <div class="output-section">
        <h2>Pixel Perfect SVG</h2>
        <div id="svgLoader" class="loader"></div>
        <textarea id="svgOutput" readonly></textarea>
        <div class="svg-preview" id="outputSvgPreview">Preview</div>
        <span id="outputSvgSize" class="svg-size"></span>
        <div class="output-buttons">
            <button id="copySvgButton">Copy SVG</button>
            <button id="downloadSvgButton">Download SVG</button>
        </div>
      </div>

    </section>

    <hr>

    <section class="centered">

      <div class="output-section">
        <h2>Optimized SVG</h2>
        <div id="optimizedSvgLoader" class="loader"></div>
        <textarea id="optimizedSvgOutput" readonly></textarea>
        <div class="svg-preview" id="optimizedOutputSvgPreview">Preview</div>
        <span id="optimizedOutputSvgSize" class="svg-size"></span>
        <div class="output-buttons">
            <button id="copyOptimizedSvgButton">Copy Optimized SVG</button>
            <button id="downloadOptimizedSvgButton">Download Optimized SVG</button>
        </div>
      </div>

    </section>
  </main>


  <script>
    // JavaScript will go here
    const imageUpload = document.getElementById('imageUpload');
    const base64Input = document.getElementById('base64Input');
    const inputImagePreview = document.getElementById('inputImagePreview');
    const inputImageSize = document.getElementById('inputImageSize');
    const svgOutput = document.getElementById('svgOutput');
    const outputSvgPreview = document.getElementById('outputSvgPreview');
    const outputSvgSize = document.getElementById('outputSvgSize');
    const copySvgButton = document.getElementById('copySvgButton');
    const downloadSvgButton = document.getElementById('downloadSvgButton');
    const svgLoader = document.getElementById('svgLoader');

    const optimizedSvgOutput = document.getElementById('optimizedSvgOutput');
    const optimizedOutputSvgPreview = document.getElementById('optimizedOutputSvgPreview');
    const optimizedOutputSvgSize = document.getElementById('optimizedOutputSvgSize');
    const copyOptimizedSvgButton = document.getElementById('copyOptimizedSvgButton');
    const downloadOptimizedSvgButton = document.getElementById('downloadOptimizedSvgButton');
    const optimizedSvgLoader = document.getElementById('optimizedSvgLoader');

    let currentImageBase64 = '';

    async function processImage(base64Data) {
      if (base64Data) {
        inputImagePreview.innerHTML = `<img src="${base64Data}" alt="Input Image Preview">`;
        currentImageBase64 = base64Data;

        const img = new Image();
        img.onload = async () => {
          inputImageSize.textContent = `Original Size: ${img.width}x${img.height} pixels`;

          // Calculate and display input image size in bytes
          try {
            const response = await fetch(base64Data);
            const blob = await response.blob();
            inputImageSize.textContent += ` (${formatBytes(blob.size)})`;
          } catch (error) {
            console.error('Failed to fetch image blob for size calculation:', error);
            inputImageSize.textContent += ' (Size unknown)';
          }

          // Show loader and clear previous SVG output
          svgLoader.style.display = 'block';
          svgOutput.value = '';
          outputSvgPreview.innerHTML = '';
          outputSvgSize.textContent = '';
          let svgBlob;

          try {
            const svgResult = await convertToPixelPerfectSVG(base64Data);
            svgOutput.value = svgResult;
            outputSvgPreview.innerHTML = svgResult;
            svgBlob = new Blob([svgResult], { type: 'image/svg+xml' });
            outputSvgSize.textContent = `SVG Size: ${formatBytes(svgBlob.size)}`;
          } catch (error) {
            console.error('SVG conversion failed:', error);
            alert('Failed to convert image to SVG. Please check the console for details.');
            svgOutput.value = '';
            outputSvgPreview.innerHTML = '';
            outputSvgSize.textContent = '';
          } finally {
            svgLoader.style.display = 'none'; // Hide loader regardless of success or failure
          }

          // Process for Optimized SVG
          optimizedSvgLoader.style.display = 'block';
          optimizedSvgOutput.value = '';
          optimizedOutputSvgPreview.innerHTML = '';
          optimizedOutputSvgSize.textContent = '';

          try {
            const optimizedSvgResult = await convertToOptimizedSVG(base64Data);
            optimizedSvgOutput.value = optimizedSvgResult;
            optimizedOutputSvgPreview.innerHTML = optimizedSvgResult;
            const optimizedSvgBlob = new Blob([optimizedSvgResult], { type: 'image/svg+xml' });
            const originalSvgSize = svgBlob.size;
            const optimizedSvgSize = optimizedSvgBlob.size;
            const percentage = ((originalSvgSize - optimizedSvgSize) / originalSvgSize) * 100;
            optimizedOutputSvgSize.textContent = `Optimized SVG Size: ${formatBytes(optimizedSvgSize)} (${percentage.toFixed(2)}% smaller)`;
          } catch (error) {
            console.error('Optimized SVG conversion failed:', error);
            alert('Failed to convert image to Optimized SVG. Please check the console for details.');
            optimizedSvgOutput.value = '';
            optimizedOutputSvgPreview.innerHTML = '';
            optimizedOutputSvgSize.textContent = '';
          } finally {
            optimizedSvgLoader.style.display = 'none';
          }
        };
        img.onerror = () => {
            inputImageSize.textContent = 'Invalid image data';
            inputImagePreview.innerHTML = '';
            currentImageBase64 = '';
            svgOutput.value = '';
            outputSvgPreview.innerHTML = '';
            outputSvgSize.textContent = '';
            svgLoader.style.display = 'none'; // Hide loader on image load error
        };
        img.src = base64Data;

      } else {
        inputImagePreview.innerHTML = '';
        inputImageSize.textContent = '';
        currentImageBase64 = '';
        svgOutput.value = '';
        outputSvgPreview.innerHTML = '';
        outputSvgSize.textContent = '';
        svgLoader.style.display = 'none'; // Hide loader if no base64 data
      }
    }

    imageUpload.addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = (e) => {
          base64Input.value = e.target.result; // Sync base64 input
          processImage(e.target.result);
        };
        reader.readAsDataURL(file);
      } else {
        base64Input.value = '';
        processImage('');
      }
    });

    base64Input.addEventListener('input', (event) => {
      processImage(event.target.value);
      imageUpload.value = ''; // Clear file input if base64 is manually entered
    });

    copySvgButton.addEventListener('click', () => {
      svgOutput.select();
      document.execCommand('copy');
      alert('SVG copied to clipboard!');
    });

    downloadSvgButton.addEventListener('click', () => {
      const svgContent = svgOutput.value;
      if (svgContent) {
        const blob = new Blob([svgContent], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'pixel-perfect.svg';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      } else {
        alert('No SVG to download.');
      }
    });

    copyOptimizedSvgButton.addEventListener('click', () => {
      optimizedSvgOutput.select();
      document.execCommand('copy');
      alert('Optimized SVG copied to clipboard!');
    });

    downloadOptimizedSvgButton.addEventListener('click', () => {
      const svgContent = optimizedSvgOutput.value;
      if (svgContent) {
        const blob = new Blob([svgContent], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'pixel-perfect-optimized.svg';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      } else {
        alert('No Optimized SVG to download.');
      }
    });

    // Helper function to format bytes into human-readable sizes
    function formatBytes(bytes, decimals = 2) {
      if (bytes === 0) return '0 Bytes';

      const k = 1024;
      const dm = decimals < 0 ? 0 : decimals;
      const sizes = ['Bytes', 'KB', 'MB'];

      const i = Math.floor(Math.log(bytes) / Math.log(k));

      return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    }

    function convertToPixelPerfectSVG(base64Image) {
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');

          canvas.width = img.width;
          canvas.height = img.height;
          ctx.drawImage(img, 0, 0);

          const imageData = ctx.getImageData(0, 0, img.width, img.height);
          const data = imageData.data;

          let svgRects = [];
          for (let y = 0; y < img.height; y++) {
            for (let x = 0; x < img.width; x++) {
              const index = (y * img.width + x) * 4;
              const alpha = data[index + 3]; // Alpha channel

              if (alpha > 0) { // Only draw if not fully transparent
                const r = data[index];
                const g = data[index + 1];
                const b = data[index + 2];
                const color = `rgb(${r},${g},${b})`;
                svgRects.push(`<rect x="${x}" y="${y}" width="1" height="1" fill="${color}"/>`);
              }
            }
          }

          const svgContent = `<svg width="${img.width}" height="${img.height}" viewBox="0 0 ${img.width} ${img.height}" xmlns="http://www.w3.org/2000/svg">
${svgRects.join("\n")}
</svg>`;
          resolve(svgContent);
        };
        img.src = base64Image;
      });
    }

    function convertToOptimizedSVG(base64Image) {
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');

          canvas.width = img.width;
          canvas.height = img.height;
          ctx.drawImage(img, 0, 0);

          const imageData = ctx.getImageData(0, 0, img.width, img.height);
          const data = imageData.data;

          const processedPixels = Array(img.height).fill(0).map(() => Array(img.width).fill(false));

          let svgElements = [];

          for (let y = 0; y < img.height; y++) {
            for (let x = 0; x < img.width; x++) {
              const index = (y * img.width + x) * 4;
              const alpha = data[index + 3];

              // If pixel is transparent or already processed, skip it
              if (alpha === 0 || processedPixels[y][x]) {
                continue;
              }

              const r = data[index];
              const g = data[index + 1];
              const b = data[index + 2];
              const currentColor = `rgb(${r},${g},${b})`;

              // Determine the maximum possible width for a rectangle starting at (x, y)
              let currentWidth = 0;
              for (let w = x; w < img.width; w++) {
                const pixelIndex = (y * img.width + w) * 4;
                const pixelAlpha = data[pixelIndex + 3];
                const pixelR = data[pixelIndex];
                const pixelG = data[pixelIndex + 1];
                const pixelB = data[pixelIndex + 2];
                const pixelColor = `rgb(${pixelR},${pixelG},${pixelB})`;

                if (pixelAlpha > 0 && pixelColor === currentColor && !processedPixels[y][w]) {
                  currentWidth++;
                } else {
                  break;
                }
              }

              // Determine the maximum possible height for this currentWidth
              let currentHeight = 0;
              for (let h = y; h < img.height; h++) {
                let rowIsSolid = true;
                for (let w = x; w < x + currentWidth; w++) {
                  const pixelIndex = (h * img.width + w) * 4;
                  const pixelAlpha = data[pixelIndex + 3];
                  const pixelR = data[pixelIndex];
                  const pixelG = data[pixelIndex + 1];
                  const pixelB = data[pixelIndex + 2];
                  const pixelColor = `rgb(${pixelR},${pixelG},${pixelB})`;

                  if (pixelAlpha === 0 || pixelColor !== currentColor || processedPixels[h][w]) {
                    rowIsSolid = false;
                    break;
                  }
                }
                if (rowIsSolid) {
                  currentHeight++;
                } else {
                  break;
                }
              }

              // Add the rectangle and mark pixels as processed
              svgElements.push(`<rect x="${x}" y="${y}" width="${currentWidth}" height="${currentHeight}" fill="${currentColor}"/>`);
              for (let h = 0; h < currentHeight; h++) {
                for (let w = x; w < x + currentWidth; w++) {
                  processedPixels[y + h][w] = true;
                }
              }
            }
          }

          const svgContent = `<svg width="${img.width}" height="${img.height}" viewBox="0 0 ${img.width} ${img.height}" xmlns="http://www.w3.org/2000/svg">
${svgElements.join("\n")}
</svg>`;
          resolve(svgContent);
        };
        img.src = base64Image;
      });
    }
  </script>




  <footer>
    <div id="footer">&copy; 2000 <a href="https://github.com/dorianbayart" title="DorianBayart on GitHub">0xDBA</a>
    </div>
  </footer>

  <script>
    const currentYear = new Date().getFullYear()
    document.querySelector('footer div#footer').innerHTML = `&copy; ${currentYear} <a href="https://github.com/dorianbayart" title="DorianBayart on GitHub">0xDBA</a>`
  </script>

</body>

<link rel="stylesheet" href="common.css">

</html>